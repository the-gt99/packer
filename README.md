### Три разновидности одной функции (Packer). 

**Packer 1** - имеет следующий параметр активации ($str). <br>
Где $str - это строка,которую нужно сжать.<br>

После вызова функции в ответ приходит массив содержащий letters  и quantity.
Где letters - буквы, а quantity их количество.
Пример:
> Вызвав функцию "packer_1" и передав ей строку: <br>
> ```php 
> //php code 
> $str = 'xAAAAAAAAAAfffffhxddgfka';
> ```
> В ответ вы получите массив Array([letters]=>Array([1]=>x[2]=>A[3]=>f[4]=>h[5]=>x[6]=>d[7]=>g[8]=>f[9]=>k[10]=>a)[quantity]=>Array([1]=>1[2]=>10[3]=>5[4]=>1[5]=>1[6]=>2[7]=>1[8]=>1[9]=>1[10]=>1)). <br>
>> Пример вызова функции:
>> ```php 
>> //php code 
>> print_r(packer_1($str));
>> ```

Соответственно для распаковки исходной строки нужно воспользоваться парной функцией для packer_1, под названием unpacker_1.<br>

Из минусов этого дуэта:<br>
1.Если исходная строка содержит много односимвольных элементов, то результат будет иметь вес больше исходной строки.<br>
Из плюсов:
1.Маленький код.
2.Быстрая работа

<br>
<br>
<br>
**Packer 2** - имеет следующий параметр активации ($str). <br>
Где $str - это строка,которую нужно сжать.<br>

После вызова функции в ответ приходит запакованная строка.

> Вызвав функцию "packer_2" и передав ей строку: <br>
> ```php 
> //php code 
> $str = 'xAAAAAAAAAAfffffhxddgfka';
> ```
> В ответ вы получите массив строку 'xA10f5hxd2gfka' <br>
>> Пример вызова функции:
>> ```php 
>> //php code 
>> print_r(packer_2($str));
>> ```

Соответственно для распаковки исходной строки нужно воспользоваться парной функцией для packer_2, под названием unpacker_2.<br>

Из минусов этого дуэта:<br>
1.Множество проверок, что приводит к медленной работе.<br>
Из плюсов:
1.Результат всегда будет не больше исходной строки.

<br>
<br>
<br>
**Packer 3** - имеет следующий параметр активации ($str). <br>
Где $str - это строка,которую нужно сжать.<br>

После вызова функции в ответ приходит массив содержащий letters  и quantity.
Где letters - буквы, а quantity их количество переведённое в ASCII.
Пример:
> Вызвав функцию "packer_3" и передав ей строку: <br>
> ```php 
> //php code 
> $str = 'xAAAAAAAAAAfffffhxddgfka';
> ```
> В ответ вы получите массив Array([letters]=>Array([1]=>x[2]=>A[3]=>f[4]=>h[5]=>x[6]=>d[7]=>g[8]=>f[9]=>k[10]=>a)[quantity]=>Array([1]=>[2]=>[3]=>[4]=>[5]=>[6]=>[7]=>[8]=>[9]=>[10]=>)). <br>
>> Пример вызова функции:
>> ```php 
>> //php code 
>> print_r(packer_3($str));
>> ```

Соответственно для распаковки исходной строки нужно воспользоваться парной функцией для packer_3, под названием unpacker_3.<br>

Из минусов этого дуэта:<br>
1.Если исходная строка содержит много односимвольных элементов, то результат будет иметь вес больше исходной строки.<br>
Из плюсов:
1.Если строка будет иметь много повторяющихся символов к пример 250 букв G, 123 буквы D, то результат будет меньше исходной строки.


//Если я не удали этот комментарий, значит я не дописал функцию, которая должна выбирать лучшую из выше перечисленных автоматический, в зависимости от исходной строки.
